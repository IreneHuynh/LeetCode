
Question 1277: Count Square Submatrices With All Ones

Brute forces:
We can divide it into three functions.
1) expanding the square
2) checking if our square contains all ones
3) And making sure it is within our bounds when we are expanding

var countSquares = function (matrix) {
    if (!matrix || !Array.isArray(matrix[0])) return 0;

    let numberOfSquares = 0;

    matrix.forEach((row, i) => {
        row.forEach((_, j) => {
            numberOfSquares += expandSquare(matrix, [i, j]);
        });
    });

    return numberOfSquares;
};

const expandSquare = function (matrix, bottomRightVertex) {
    let numberOfSquares = 0;
    let topLeftVertex = [...bottomRightVertex];
    while (isSquare(matrix, topLeftVertex, bottomRightVertex)) {
        numberOfSquares += 1;
        topLeftVertex[0] -= 1;
        topLeftVertex[1] -= 1;
    }
    return numberOfSquares;
};

const isSquare = function (matrix, topLeftVertex, bottomRightVertex) {
    const [i, j] = topLeftVertex;
    const [r, c] = bottomRightVertex;

    if (!inBound(topLeftVertex)) {
        return false;
    }

    for (let a = i; a <= r; a++) {
        for (let b = j; b <= c; b++) {
            if (matrix[a][b] == 0) return false;
        }
    }

    return true;
};
const inBound = function ([i, j]) {
    return i >= 0 && j >= 0;
};


To Optimize we just use a memo:
We are just storing the previous counts at each matrix, rather than doing the expanding out method, we will be checking with of the neighbouring values in the matrix has a min value. This is similar to the expansion method, however we are no long expanding out we are checking the safest number that we can choose, because we are just adding on to our current count. We are checking the top, left and the diagonal spaces to see what is the safest number that we previously expanded by.

const countSquares = matrix => {
  let count = 0;
  for (let i = 0; i < matrix.length; ++i) {
    for (let j = 0; j < matrix[0].length; ++j) {
      if (matrix[i][j] === 0) continue;
      if (i > 0 && j > 0) {
        matrix[i][j] += Math.min(matrix[i - 1][j], matrix[i][j - 1], matrix[i - 1][j - 1]);
      }
      count += matrix[i][j];
    }
  }
  return count;
};
