
Question 1: Two Sums-------------------------------------------------------------------------------------------------------------------------Question 1: Two Sums
Brute Force Approach: I would just iterate through the array using two pointers
and if they add to the target I would return their indices, otherwise I would
return an error

Run time is O(n^2) 

var twoSum = function(nums, target) {
    for(let i = 0; i< nums.length - 1; i++){
        for(let j = i+1; j< nums.length; j++){
            if(nums[i]+nums[j] == target) return [i,j];   
        }
    }throw new TypeError("No solution");
    
};

Optimal Approach: I would calculate the complement value of each number and store that
value in a map. The map has a key of the element in the array and the value is the index
As I iterate through the array, if I encounter the complement I would
return the indices of both the elements.

Run time is 0(n)

var twoSum = function(nums, target) {
    const compMap = new Map();
    for (const num in nums) {
        const complement = target - nums[num];
        if (compMap.has(complement)) {
            return [num, compMap.get(complement)]
        }
        compMap.set(nums[num], num);
    }
};


Question 2: Add Two Numbers-----------------------------------------------------------------------------------------------------------Question 2: Add Two Numbers

Brute force: We would iterate through each list to check if the node exist and if there is a value
We would then add the two values up and see if the value would be greater than 10
If it we introduce an element named carry, which will either be 1 or 0; We continues add the values
in the node list up along with the carry value. After the end of the list we want to check if there
is a carry value at the end

var addTwoNumbers = function(l1, l2) {
   let p1 = l1;
   let p2 = l2;
   let num1 = 0;
   let num2 = 0; 
   let carry = 0;
   let solution = new ListNode(0);
   let current = solution;
     
   while (p1 || p2 ){
     num1 = (p1) ? p1.val : 0;
     num2 = (p2) ? p2.val : 0;
   
     if(num1 + num2 + carry > 9){
         current.next = new ListNode(num1 + num2 + carry - 10);
         current = current.next;
         carry = 1;
     } else {
         current.next = new ListNode(num1 + num2 + carry);
         current = current.next;
         carry = 0;
     }
     
     if(p1) p1 = p1.next;
     if(p2) p2 = p2.next;
   }
    
   current.next = carry? new ListNode(carry): 0;
   return solution.next;
};

This is an example of a recursive answer using the same logic

var addTwoNumbers = function(l1, l2) {
   function helper(list1 = l1, list2= l2, carry= 0) {
        if(!list1 && !list2 && !carry) return null;
        let sum = carry, next1 = null, next2 = null;
        
        if(list1 && list2) {
            sum += (list1.val + list2.val);
            next1 = list1.next;
            next2 = list2.next;
        } else if(list1) {
            sum += list1.val;
            next1 = list1.next;
        } else if(list2) {
            sum += list2.val;
            next2 = list2.next;
        }
        
        const newList = new ListNode(sum%10);
        newList.next = helper(next1, next2, Math.floor(sum/10))
        return newList;
    }
    
    return helper();
};

Question 3: Longest Substring Without Repeating Characters---------------------------------------------Question 3: Longest Substring Without Repeating Characters

I like to think of this question like a sliding window. Where we have two 
pointers the head and the tail and everytime we encounter a character that
we have seen before we just add.
Brute force:


Optimals:
var lengthOfLongestSubstring = function(s) {
    let left = 0;
    let right = 0;
    let maxlength = 0;
    let set = new Set();
    
    while(right < s.length){
        if(!set.has(s.charAt(right))){
            set.add(s.charAt(right));
            right++;
            maxlength = Math.max(set.size, maxlength);         
        }
        else{
            set.delete(s.charAt(left));
            left++;
        }
    }
    return maxlength;
};
Question 4: Median of Two sorted Arrays-----------------------------------------------------------------------------------Question 4: Median of Two sorted Arrays



Question 5: Longest Palindromic Substring-------------------------------------------------------------------------------Question 5: Longest Palindromic Substring
My thinking process towards this is if I start from the outer array and compare the letters towards the middle I can check if there exist two characters that are
the same. If two aren't I continue inwards. 
Brute Force:
function isPalindrome(s) {
    let k = 0;
    let l = s.length - 1;
    let isPalindrome = true;
    while(k<=l) {
        if (!(s.charAt(k) === s.charAt(l))) {
            isPalindrome = false;
            break;
        }
        k++;
        l--;
    }
    return isPalindrome;
}


function longestPalindrome(s) {

    let maxPalindrome = "";
    
    for (let i = 0; i <= s.length-1; i++) {
        for (let j = i+1; j <= s.length; j++) {
            let subStr = s.substring(i, j);
            if (isPalindrome(subStr)) {
                if (subStr.length > maxPalindrome.length) {
                        maxPalindrome = subStr;
                }
            } 
        }
    }  
    
    return maxPalindrome;
}


Optimal: I am bubbling from the middle outwards, the approach is similar but optimal because everything is done recursively
var longestPalindrome = function(s) {
    let maxSub = '';
    
    const bubbleFromCenter = (left, right) => {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return s.slice(left+1, right)
    }
    
    for(let i = 0; i < s.length; i++) {
        const sub1 = bubbleFromCenter(i, i);
        const sub2 = bubbleFromCenter(i, i+1);
        const sub = sub1.length > sub2.length ? sub1 : sub2
        if(sub.length > maxSub.length) {
            maxSub = sub
        }
    }
    return maxSub
};


Question 6: Zigzap Conversation---------------------------------------------------------------------------------------------------Question 6: Zigzap Conversation
Optimal:
var convert = function(s, numRows) {
  if (numRows === 1) return s;

  let y = 0;
  let isZigging = true;
  const rows = [...new Array(numRows)].map( el => []);

  for (let i = 0; i < s.length; i++) {
    rows[y].push(s[i]);

    if (y === numRows - 1) isZigging = false;
    if (y === 0) isZigging = true;

    y = isZigging ? y + 1 : y - 1;
  }

  return rows.reduce((acc, row) => string + row.join(''), '');
};
Question 7: Reverse Integer-----------------------------------------------------------------------------------------------------------Question 7: Reverse Integer
const reverse = (x) => {
  let absX = Math.abs(x);
  let result = '';

  while (absX > 0) {
    result += absX % 10;
    absX = ~~(absX / 10);
  }

  if (result < -(2 ** 31) || result > 2 ** 31 - 1) {
    return 0;
  }

  return x < 0 ? -result : +result;
};

Question 8: String to Integer-------------------------------------------------------------------------------------------------------Question 8: String to Integer
var myAtoi = function(str) {
    
    let strArr = str.trim().split(" ")[0];
    strArr = parseInt(strArr);
    if( strArr > (2 ** 31) -1) return (2 ** 31) -1;
    else if ( strArr < (-2)**31) return ((-2) ** 31);
    return Number.isInteger(strArr)? strArr: 0;
    
};

Question 9: Palindrome Number-------------------------------------------------------------------------------------------------------Question 9: Palindrome Number
Brute Force: The idea behind this is to pop off the last ligit until we can effectively produce a copy of the input function and at that point we compare 

const isPalindrome = (x) => {
  const str = String(x);
  if (str.length === 1) return true;
  const reverse = value => {
    let result = '';
    for (let i = value.length - 1; i >= 0; i -= 1) {
      result += value[i];
    }
    return result;
  }
  return reverse(str) === str;
};

Again there is no optimal solution to this because this is alread O(n)work.

Question 39: Combination Sum---------------------------------------------------------------------------------------------------------Question 39: Combination Sum

Brute Force: We simply want to collect the possible combinations if it reaches the target. This is where the backtracking technique comes in handing. We will only add a list of possible combinations if it reaches the target sum.

var combinationSum = function(candidates, target) {
    const res = [];
    candidates.sort();
    function permute(arr=[], remain = target, index=0) {
        if(remain < 0) return;
        else if(remain === 0) res.push(arr);
        for(let i = index; i < candidates.length; i++) {
            permute([...arr, candidates[i]], remain-candidates[i], i);
        }
    }
    permute()
    return res;
};

We wouldn't be able to memoize this because we trust the backtracking and also we are not revisiting any past combinations. Basically we wouldn't be able to optimize the solution any further.


Question 53: Maximum Subarray-------------------------------------------------------------------------------------------------------Question 53: Maximum Subarray
We can use kadanes algorithm which is prefixSum

const maxSubArray = function(nums) {
    let max_ending_here = 0;
    let max_so_far = -Number.MAX_VALUE;

  for (let i = 0; i < nums.length; i++) {
      max_ending_here = Math.max(max_ending_here + nums[i], nums[i]);
      max_so_far =  Math.max(max_ending_here, max_so_far);
  }
    
  return max_so_far;
};



Question 95: Unique Binary Search Trees II-----------------------------------------------------------------------------Question 95: Unique Binary Search Trees II
Brute force:

var generateTrees = function(n) {
    if(n <= 0) {
        return [];
    }
    return solve(1, n);
};

function solve(start, end) {
    var treeList = [];
    if(start > end) {
        treeList.push(null);
        return treeList;
    }
    for(var i = start; i <= end; i++) {
        var leftList = solve(start, i - 1);
        var rightList = solve(i + 1, end);
        
        for(var j = 0; j < leftList.length; j++) {
            for(var k = 0; k < rightList.length; k++) {
                var curNode = new TreeNode(i);
                curNode.left = leftList[j];
                curNode.right = rightList[k];
                treeList.push(curNode);
            }
        }
    }
    return treeList;
}

Using the optimal: all we do similiar to the previous question is we memoize it.

var generateTrees = function(n) {
    if(n == 0) return [];
    let map = new Map();
    
    let helper = function(lo = 1, high = n){
        const result = []
        if(lo > high) {
            result.push(null);
            return result
        }
        const key = `${lo}#${high}`;
        if(map.has(key)) return map.get(key);
        for(let i=lo; i<=high; i++) {
            const leftNodes = helper(lo, i-1)
            const rightNodes = helper(i+1, high)

            for(let j=0; j<leftNodes.length; j++) {
                for(let k=0; k<rightNodes.length; k++) {
                    const root = new TreeNode(i);
                    root.left = leftNodes[j];
                    root.right = rightNodes[k];
                    result.push(root)
                }
            }
        }
        map.set(key, result);
        return result;
    }
    return helper();
};
