
Question 1: Two Sums-------------------------------------------------------------------------------------------------------------------------Question 1: Two Sums
Brute Force Approach: I would just iterate through the array using two pointers
and if they add to the target I would return their indices, otherwise I would
return an error

Run time is O(n^2) 

var twoSum = function(nums, target) {
    for(let i = 0; i< nums.length - 1; i++){
        for(let j = i+1; j< nums.length; j++){
            if(nums[i]+nums[j] == target) return [i,j];   
        }
    }throw new TypeError("No solution");
    
};

Optimal Approach: I would calculate the complement value of each number and store that
value in a map. The map has a key of the element in the array and the value is the index
As I iterate through the array, if I encounter the complement I would
return the indices of both the elements.

Run time is 0(n)

var twoSum = function(nums, target) {
    const compMap = new Map();
    for (const num in nums) {
        const complement = target - nums[num];
        if (compMap.has(complement)) {
            return [num, compMap.get(complement)]
        }
        compMap.set(nums[num], num);
    }
};



Question 2: Add Two Numbers-----------------------------------------------------------------------------------------------------------Question 2: Add Two Numbers

Brute force: We would iterate through each list to check if the node exist and if there is a value
We would then add the two values up and see if the value would be greater than 10
If it we introduce an element named carry, which will either be 1 or 0; We continues add the values
in the node list up along with the carry value. After the end of the list we want to check if there
is a carry value at the end

var addTwoNumbers = function(l1, l2) {
   let p1 = l1;
   let p2 = l2;
   let num1 = 0;
   let num2 = 0; 
   let carry = 0;
   let solution = new ListNode(0);
   let current = solution;
     
   while (p1 || p2 ){
     num1 = (p1) ? p1.val : 0;
     num2 = (p2) ? p2.val : 0;
   
     if(num1 + num2 + carry > 9){
         current.next = new ListNode(num1 + num2 + carry - 10);
         current = current.next;
         carry = 1;
     } else {
         current.next = new ListNode(num1 + num2 + carry);
         current = current.next;
         carry = 0;
     }
     
     if(p1) p1 = p1.next;
     if(p2) p2 = p2.next;
   }
    
   current.next = carry? new ListNode(carry): 0;
   return solution.next;
};

This is an example of a recursive answer using the same logic

var addTwoNumbers = function(l1, l2) {
   function helper(list1 = l1, list2= l2, carry= 0) {
        if(!list1 && !list2 && !carry) return null;
        let sum = carry, next1 = null, next2 = null;
        
        if(list1 && list2) {
            sum += (list1.val + list2.val);
            next1 = list1.next;
            next2 = list2.next;
        } else if(list1) {
            sum += list1.val;
            next1 = list1.next;
        } else if(list2) {
            sum += list2.val;
            next2 = list2.next;
        }
        
        const newList = new ListNode(sum%10);
        newList.next = helper(next1, next2, Math.floor(sum/10))
        return newList;
    }
    
    return helper();
};

Question 3: Longest Substring Without Repeating Characters------------------

I like to think of this question like a sliding window. Where we have two 
pointers the head and the tail and everytime we encounter a character that
we have seen before we just add.
Brute force:



Optimals:
var lengthOfLongestSubstring = function(s) {
    let left = 0;
    let right = 0;
    let maxlength = 0;
    let set = new Set();
    
    while(right < s.length){
        if(!set.has(s.charAt(right))){
            set.add(s.charAt(right));
            right++;
            maxlength = Math.max(set.size, maxlength);         
        }
        else{
            set.delete(s.charAt(left));
            left++;
        }
    }
    return maxlength;
};

Question 5--------------
function isPalindrome(s) {
    let k = 0;
    let l = s.length - 1;
    let isPalindrome = true;
    while(k<=l) {
        if (!(s.charAt(k) === s.charAt(l))) {
            isPalindrome = false;
            break;
        }
        k++;
        l--;
    }
    return isPalindrome;
}

function longestPalindrome(s) {

    let maxPalindrome = "";
    
    for (let i = 0; i <= s.length-1; i++) {
        for (let j = i+1; j <= s.length; j++) {
            let subStr = s.substring(i, j);
            if (isPalindrome(subStr)) {
                if (subStr.length > maxPalindrome.length) {
                        maxPalindrome = subStr;
                }
            } 
        }
    }  
    
    return maxPalindrome;
}


var longestPalindrome = function(s) {
    let maxSub = '';
    
    const bubbleFromCenter = (left, right) => {
        while(left >= 0 && right < s.length && s[left] === s[right]) {
            left--;
            right++;
        }
        return s.slice(left+1, right)
    }
    
    for(let i = 0; i < s.length; i++) {
        const sub1 = bubbleFromCenter(i, i);
        const sub2 = bubbleFromCenter(i, i+1);
        const sub = sub1.length > sub2.length ? sub1 : sub2
        if(sub.length > maxSub.length) {
            maxSub = sub
        }
    }
    return maxSub
};
Question 6-------------------------------------------
var convert = function(s, numRows) {
  if (numRows === 1) return s;

  let y = 0;
  let isZigging = true;
  const rows = [...new Array(numRows)].map( el => []);

  for (let i = 0; i < s.length; i++) {
    rows[y].push(s[i]);

    if (y === numRows - 1) isZigging = false;
    if (y === 0) isZigging = true;

    y = isZigging ? y + 1 : y - 1;
  }

  return rows.reduce((acc, row) => string + row.join(''), '');
};
Question 7-------------------------------------------------------
const reverse = (x) => {
  let absX = Math.abs(x);
  let result = '';

  while (absX > 0) {
    result += absX % 10;
    absX = ~~(absX / 10);
  }

  if (result < -(2 ** 31) || result > 2 ** 31 - 1) {
    return 0;
  }

  return x < 0 ? -result : +result;
};
