Question: 1105: Filling Bookcase Shelves

Brute Force:
We simply ask ourselves if we should add the book or not, then it becomes a tree like pattern.
If we add the book to the shelf we decrease the width remaining, otherwise we add to the existing height;

var minHeightShelves = function(books, shelf_width) {
    let helper = function(index = 0,curheight= 0, remainingWidth = shelf_width){
        if(index == books.length) return curheight;
        minheight = Infinity;
        let [width, height] = books[index];
        if(curheight == 0) minheight = helper(index + 1, height, remainingWidth - width);
        else if(width > remainingWidth) minheight = curheight + helper(index, 0, shelf_width);
        else{
            minheight = Math.min( helper(index+1, Math.max(curheight, height), remainingWidth - width),
                                 curheight + helper(index ,0, shelf_width));
        }
        return minheight;
        
    }
    return helper();
};

Optimal Solution: 
Similar to other case, the optimal solution is just a memo;

var minHeightShelves = function(books, shelf_width) {
    let helper = function(index = 0,curheight = 0, remainingWidth = shelf_width){
        if(index == books.length) return curheight;
        minheight = Infinity;
        let [width, height] = books[index];
        if(curheight == 0) minheight = helper(index + 1, height, remainingWidth - width);
        else if(width > remainingWidth) minheight = curheight + helper(index, 0, shelf_width);
        else{
            minheight = Math.min( helper(index+1, Math.max(curheight, height), remainingWidth - width),
                                 curheight + helper(index ,0, shelf_width));
        }
        return minheight;
    }
    return helper();
};






Question 1113:

var largest1BorderedSquare = function(grid) {
    let max = 0;
    //Time coplexity O(n^2 * n^2) = O(n^4) where n is grid length;
    // Space comeplxity O(1);
    grid.forEach((row, i) => {
        row.forEach((cell, j) => {
            max = Math.max(max, rec(grid, i, j, i, j));
        })
    })
    return max;
};

const rec = (grid , i, j, k, r) => {
    // Time complexity O(n * 2) where n is grid length;
    // Space comeplxity O(1);
    
    if (k > grid.length - 1 || r > grid[0].length - 1) return 0;
    
    let max = isValidSquare(grid, i, j, k, r) ? (k - i + 1) * (r - j + 1) : 0;
    
    return Math.max(max, rec(grid, i, j, k + 1, r + 1))
}

const isValidSquare = (grid, i, j, k, r) => {
    
    // Time complexity O(n) where n is grid length;
    // Space comeplxity O(1);
    for (let row = i; row <= k; row++) {
        if (grid[row][j] == 0 || grid[row][r] == 0) return false;
    }
    
    for (let col = j; col <= r; col++) {
        if (grid[i][col] == 0 || grid[k][col] == 0) return false;
    }
    
    return true;
}
