Question 228: Summary Ranges

Again this is two pointer. We just want to compare the prev with the next to make sure there is a difference of 1. After finding the range we just push

var summaryRanges = function(nums) {
    const ranges = [];
    let i = 0;
    // Iterate through `nums` and use `j` to identify incontinuity.
    // When incontinuity occurs, compose the current range and set `i`
    // for the new starting point.
    for (let j = 1; j <= nums.length; j++) {
        if (nums[j] !== nums[j - 1] + 1) {
            if (i === j - 1) {
                ranges.push(`${nums[i]}`);
            } else {
                ranges.push(`${nums[i]}->${nums[j - 1]}`);    
            }          
            i = j;
        }
    }
    return ranges;
};

Question 278: First Bad Version------------------------------------------------------------------------------------------------------Question 278: First Bad Version

Optimal Solution:
Here I am using the bisect right algorith for searching! Since we are return the element to the right of the bad version.

var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n){
    
    let lo = 1;
    let hi = n;
    let mid = null

    while (lo <= hi){
        let mid = Math.floor((lo + hi)/2);
        if(isBadVersion(mid) ){
            bad = mid
            hi = mid - 1;
        } else {
            lo = mid + 1;
        }
        
    }
        return bad;
  }
}

