Question 228: Summary Ranges

Again this is two pointer. We just want to compare the prev with the next to make sure there is a difference of 1. After finding the range we just push

var summaryRanges = function(nums) {
    const ranges = [];
    let i = 0;
    // Iterate through `nums` and use `j` to identify incontinuity.
    // When incontinuity occurs, compose the current range and set `i`
    // for the new starting point.
    for (let j = 1; j <= nums.length; j++) {
        if (nums[j] !== nums[j - 1] + 1) {
            if (i === j - 1) {
                ranges.push(`${nums[i]}`);
            } else {
                ranges.push(`${nums[i]}->${nums[j - 1]}`);    
            }          
            i = j;
        }
    }
    return ranges;
};

Question 229: Majority Number II

In this case we are looking for linear time and space complexity of constant. Then we have to refer to Boyer Moore
var majorityElement = function(nums) {
    const n = nums.length
    if (n < 1) return []
    if (n < 2) return nums
    
    let count1 = 0, count2 = 0, candidate1 = 0, candidate2 = 1
    
    for (let i = 0; i < n; i++) {
        if (nums[i] == candidate1) count1++
        else if (nums[i] == candidate2) count2++
        else if (count1 == 0) {
            candidate1 = nums[i]
            count1 = 1
        } 
        else if (count2 == 0) {
            candidate2 = nums[i]
            count2 = 1
        } else {
            count1--
            count2--
        }
    }
    
    let x = []
    if (nums.count(candidate1) > n / 3) x.push(candidate1)
    if (nums.count(candidate2) > n / 3) x.push(candidate2)
        
    return x
};
Array.prototype.count = function(num) {
    let count = 0
    for (let i = 0; i < this.length; i++)
        if (this[i] == num) count++
    
    return count
}

Question 278: First Bad Version------------------------------------------------------------------------------------------------------Question 278: First Bad Version

Optimal Solution:
Here I am using the bisect right algorith for searching! Since we are return the element to the right of the bad version.

var solution = function(isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function(n){
    
    let lo = 1;
    let hi = n;
    let mid = null

    while (lo <= hi){
        let mid = Math.floor((lo + hi)/2);
        if(isBadVersion(mid) ){
            bad = mid
            hi = mid - 1;
        } else {
            lo = mid + 1;
        }
        
    }
        return bad;
  }
}

